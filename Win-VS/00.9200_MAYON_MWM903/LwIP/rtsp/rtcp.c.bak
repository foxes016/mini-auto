#include <stdio.h>
#include "general.h" 
#include "../LwIP/include/lwip/net.h"
#include "arp.h"
#include "cksum.h"
#include "http.h"
#include "tcp.h"
#include "CARD.h"
#include "../LwIP/include/lwip/rtp.h"
#include "../LwIP/include/lwip/rtsp.h"
#include "../LwIP/include/lwip/rtcp.h"

extern CONNECTION  rtsp_conxn[];	  //保存TCP連接時的信息
extern RTC_DATE_TIME   SetTime;
RTCP_stats rtcp_recv_stats[2];
int RTCP_recv_packet(u8 *rtcp_inbuffer, u16 rtcp_insize)
{
    short len=0;
    for (len=0; len< rtcp_insize; len+=(bSwap16(*((short*)&( rtcp_inbuffer[len+2])))+1)*4) 
    {
        /*解析數據包的類型,做不同的內部處理*/
        switch (rtcp_inbuffer[1+len]) 
        {
            case SR: 
                {
                    int ssrc_count,i;
                    unsigned char tmp[4];
                    DEBUG_RTCP("RTCP SR packet received\n");

                    /*填充緩衝區中的各個變量*/
                     rtcp_recv_stats[i_client].SR_received += 1;
                     rtcp_recv_stats[i_client].pkt_count=*((int*)&( rtcp_inbuffer[20+len]));
                     rtcp_recv_stats[i_client].octet_count=*((int*)&(rtcp_inbuffer[24+len]));
                    ssrc_count=rtcp_inbuffer[0+len] & 0x1f;
                    
                    for (i=0; i<ssrc_count; ++i) 
                    {
                         rtcp_recv_stats[i_client].fract_lost=rtcp_inbuffer[32+len];
                        tmp[0]=0;
                        tmp[1]=rtcp_inbuffer[33+len];
                        tmp[2]=rtcp_inbuffer[34+len];
                        tmp[3]=rtcp_inbuffer[35+len];
                         rtcp_recv_stats[i_client].pkt_lost=bSwap32(*((int*)tmp));
                         rtcp_recv_stats[i_client].highest_seq_no=bSwap32(rtcp_inbuffer[36+len]);
                         rtcp_recv_stats[i_client].jitter=bSwap32(rtcp_inbuffer[40+len]);
                         rtcp_recv_stats[i_client].last_SR=bSwap32(rtcp_inbuffer[44+len]);
                         rtcp_recv_stats[i_client].delay_since_last_SR=bSwap32(rtcp_inbuffer[48+len]);
                    }
                    break;
                }
                
            case RR: 
                {
                    int ssrc_count,i;
                    unsigned char tmp[4];
                    DEBUG_RTCP("RTCP RR packet received\n");
                     rtcp_recv_stats[i_client].RR_received += 1;
                    ssrc_count=rtcp_inbuffer[0+len] & 0x1f;
                    for (i=0; i<ssrc_count; ++i) {
                    rtcp_recv_stats[i_client].fract_lost=rtcp_inbuffer[12+len];
                    tmp[0]=0;
                    tmp[1]=rtcp_inbuffer[13+len];
                    tmp[2]=rtcp_inbuffer[14+len];
                    tmp[3]=rtcp_inbuffer[15+len];
                     rtcp_recv_stats[i_client].pkt_lost=bSwap32(*((int*)tmp));
                     rtcp_recv_stats[i_client].highest_seq_no=bSwap32(rtcp_inbuffer[16+len]);
                     rtcp_recv_stats[i_client].jitter=bSwap32(rtcp_inbuffer[20+len]);
                     rtcp_recv_stats[i_client].last_SR=bSwap32(rtcp_inbuffer[24+len]);
                     rtcp_recv_stats[i_client].delay_since_last_SR=bSwap32(rtcp_inbuffer[28+len]);
                    }   
                    break;
                }
                
            case SDES: 
                {
                    DEBUG_RTCP("RTCP SDES packet received\n");
                    switch (rtcp_inbuffer[8]) 
                    {
                        case CNAME: 
                            {
                                 rtcp_recv_stats[1].dest_SSRC=bSwap16(*((u16*)&(rtcp_inbuffer[4])));
                                break;
                            }
                            
                        case NAME:
                            {
                                break;
                            }
                            
                        case EMAIL: 
                            {
                                break;
                            }
                            
                        case PHONE: 
                            {
                                break;
                            }
                            
                        case LOC:
                            {
                                break;
                            }
                        case TOOL: 
                            {
                                break;
                            }
                            
                        case NOTE:
                            {
                                break;
                            }
                            
                        case PRIV: 
                            {
                                break;
                            }
                            
                    }
                    
                    break;
                }
                
            case BYE:
                {   
                    DEBUG_RTCP("RTCP BYE packet received\n");
                    break;
                }
                
            case APP:
                {
                    DEBUG_RTCP("RTCP APP packet received\n");
                    break;
                }
                
            default: 
                {
                    DEBUG_RTCP("Unknown RTCP received and ignored.\n");
                    return ERR_NOERROR;
                }
                
        }
        
    }
    
    return ERR_NOERROR;
}

u32 Getntp()
{
      u32 SecCount;
      u32 i, day = 0;
      u32 Calendar_Day[13] = {   0,  31,  28,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31  };

       for (i = 1900; i < 2000 + SetTime.year; i++)
        {
            if (i%4 == 0)   /*leap year*/
                day +=366;
            else
                day +=365;

            if(i%100 == 0)
            {
                if(i%400 == 0)
                    ;
                else
                    day-=1;
            }
            //DEBUG_GPIU("day=0x%08x\n",day);
        }
        for (i = 1; i < SetTime.month; i++)
        {
            day+=Calendar_Day[i];
        }
        //DEBUG_GPIU("@@day=0x%08x\n",day);
        if ((SetTime.month > 2) && (SetTime.year%4 == 0))  /*leap year*/
            day++;
        day += SetTime.day-1;
        //DEBUG_GPIU("##day=0x%08x\n",day);
        
        SecCount = day*86400+SetTime.hour*3600+SetTime.min*60+SetTime.sec;
		
		return SecCount;
		
}
int RTCP_send_packet(RTCP_send_info *buf_info,RTP_session *session,rtcp_pkt_type type)
{
    unsigned char *pkt=NULL;
    RTCP_header hdr;
    u32 pkt_size=0,hdr_s=0;
    struct timeval ntp_time;
    /*通用頭*/
    hdr.version=2;
    hdr.padding=0;
    hdr.pt=type;
    hdr_s=sizeof(hdr);

    /*根據不同的包類型封裝RTCP數據包*/
    switch (type) 
    {
        case SR: /*sender report*/
            {
                
                RTCP_header_SR hdr_sr;
                int hdr_sr_s;

                /*填充頭數據*/
                hdr_sr_s=sizeof(hdr_sr);
                pkt_size=hdr_s+hdr_sr_s;
                hdr.length=bSwap16((pkt_size >> 2) -1);    /*用32位字表示的數減去1*/
                
                hdr.count=0;
                hdr_sr.ssrc=bSwap32(session->ssrc);

                ntp_time.tv_sec=Getntp();
                hdr_sr.ntp_timestampH = bSwap32(ntp_time.tv_sec);
                hdr_sr.ntp_timestampL = bSwap32(ntp_time.tv_usec);
                hdr_sr.rtp_timestamp = bSwap32(session->rtptime);

                hdr_sr.pkt_count=session->rtcp_stats.pkt_count;
                hdr_sr.octet_count=session->rtcp_stats.octet_count;
                
                pkt=(unsigned char*)calloc(1,pkt_size);
                if (pkt==NULL) 
                {
                    return ERR_ALLOC;
                }

                /*填充頭數據*/
                memcpy(pkt,&hdr,hdr_s);
                memcpy(pkt+hdr_s,&hdr_sr,hdr_sr_s);
                //fprintf(stderr,"pkt_size=%d,hdr_s=%d,hdr_sr_s=%d\n",pkt_size,hdr_s,hdr_sr_s);
                break;
            }
            
        case RR: /*receiver report*/
            {
                RTCP_header_RR hdr_rr;
                int hdr_rr_s;

                hdr_rr_s=sizeof(hdr_rr);
                
                pkt_size=hdr_s+hdr_rr_s;
                hdr.length=bSwap16((pkt_size >> 2) -1);
                
                hdr.count=0;
                hdr_rr.ssrc=bSwap32(session->ssrc);
                
                pkt=(unsigned char*)calloc(1,pkt_size);
                if (pkt==NULL)
                {
                    return ERR_ALLOC;
                }
                /*填充頭數據*/
                memcpy(pkt,&hdr,hdr_s);
                memcpy(pkt+hdr_s,&hdr_rr,hdr_rr_s);
                break;
            }
            
        case SDES: 
            {
                RTCP_header_SDES hdr_sdes;
                char *name;
                int hdr_sdes_s,name_s;
				char hostname[]={"unnamed stream"};
                //DEBUG_GPIU("SDES\n");
                name=hostname;
                name_s=strlen(name);
                hdr_sdes_s=sizeof(hdr_sdes);

                pkt_size=(((hdr_s+hdr_sdes_s+name_s)%4)?1:0)+(hdr_s+hdr_sdes_s+name_s);
                hdr.length=bSwap16((pkt_size >> 2) -1);

                pkt=(unsigned char*)calloc(1,pkt_size);
                if (pkt==NULL) 
                {
                    return ERR_ALLOC;
                }
                hdr.count=1;
                hdr_sdes.ssrc=bSwap32(session->ssrc);
                hdr_sdes.attr_name=bSwap32(1);	// 1=CNAME
                hdr_sdes.len=bSwap32(name_s);
                memcpy(pkt,&hdr,hdr_s);
                memcpy(pkt+hdr_s,&hdr_sdes,hdr_sdes_s);
                memcpy(pkt+hdr_s+hdr_sdes_s,name,name_s);
                break;
            }
            
        case BYE: 
            {
                RTCP_header_BYE hdr_bye;
                int hdr_bye_s;
                char *reason="The medium is over.";
                //DEBUG_GPIU("BYE\n");
                hdr_bye_s=sizeof(hdr_bye);
                pkt_size=hdr_s+hdr_bye_s;
                hdr.length=bSwap16((pkt_size >> 2) -1);
                hdr.count=1;
                hdr_bye.ssrc=bSwap32(session->ssrc);
                hdr_bye.length=bSwap32(strlen(reason));
                
                pkt=(unsigned char*)calloc(1,pkt_size);
                if (pkt==NULL) 
                {
                    return ERR_ALLOC;
                }
                
                memcpy(pkt,&hdr,hdr_s);
                memcpy(pkt+hdr_s,&hdr_bye,hdr_bye_s);
                break;	
            }
            
        default: 
            {
                return ERR_NOERROR;
            }
    }

    /*檢查數據緩衝區空間是否足夠*/
    if (buf_info->rtcp_outsize+pkt_size<=sizeof(buf_info->rtcp_outbuffer)) 
    {
        memcpy(buf_info->rtcp_outbuffer+buf_info->rtcp_outsize,pkt,pkt_size);
        buf_info->rtcp_outsize+=pkt_size;
    }
    else 
    {
        DEBUG_RTCP("Output RTCP packet lost\n");
    }
    
    free(pkt);
    return ERR_NOERROR;
}

int RTCP_handler(RTP_session *session)
{
    struct timeval t;
    struct RTCP_send_info rtcp_info;
	
	rtcp_info.rtcp_outsize = 0;
	
    /*包的個數是20的整數倍*/
	if(session->started)
		{
    	if (session->rtcp_stats.pkt_count%20==0) 
    		{
        		if (session->rtcp_stats.pkt_count==0) 
            		RTCP_send_packet(&rtcp_info,session,RR);
       		 	else 
            		RTCP_send_packet(&rtcp_info,session,SR);//sender
            
        			RTCP_send_packet(&rtcp_info,session,SDES);
        
        /*---------------SEND PKT----------------------*/

        RTCP_udp_send(session->transport.server_ports.RTCP,  session->transport.client_ports.RTCP,
                rtsp_conxn[0].ipaddr,rtcp_info.rtcp_outbuffer, session->dest_hwaddr, rtcp_info.rtcp_outsize);


    		}
		}
	else
	if(session->pause)
		{

		RTCP_send_packet(&rtcp_info,session,SR);
    	RTCP_send_packet(&rtcp_info,session,BYE);
	
		RTCP_udp_send(session->transport.server_ports.RTCP,  session->transport.client_ports.RTCP,
                rtsp_conxn[0].ipaddr,rtcp_info.rtcp_outbuffer, session->dest_hwaddr, rtcp_info.rtcp_outsize);

    	} 

    return ERR_NOERROR;
}

