/*
*  (C) Copyright 2014-2016 Shenzhen South Silicon Valley microelectronics co.,limited
*
*  All Rights Reserved
*/


#include "rtos.h"
#include "os_cfg.h"
#include <Porting.h>

volatile u8 gOsFromISR;
static u8 os_init_flag = 0;

static struct _rand_state* rand_state_list[OS_LOWEST_PRIO+1];

#define TOTAL_STACK_SIZE 516
#define STATIC_STK
#ifdef STATIC_STK
//(TOTAL_STACK_SIZE<<4) --> transfer unit to bytes
//((TOTAL_STACK_SIZE<<4)>>2) --> transfer unit to word
u32 task_stack[((TOTAL_STACK_SIZE<<4)>>2)];
u32 stk_used = 0;
OsMutex StkMutex = 0;
#endif

u32 task_stack_size = 0;

OS_APIs s32  OS_Init( void )
{
    if (os_init_flag == 1)
    {
        return 0;
    }

    os_init_flag = 1;
    memset(rand_state_list, 0, sizeof(rand_state_list));
    gOsFromISR = 0;
    //enable uc-os timer
    //timer_freq_setup(0, OS_TICKS_PER_SEC, 0, OSTimeTick);
#ifdef STATIC_STK
    if(!StkMutex)
        OS_MutexInit(&StkMutex);
    task_stack_size = ((TOTAL_STACK_SIZE<<4)>>2) * 4;
    OS_MemSET(task_stack, 0, sizeof(task_stack));
#endif

#if OS_TASK_CREATE_EXT_EN > 0
    memset(taskUserData,0,sizeof(taskUserData));
#endif
#if(OS_TASK_STAT_EN==1)
    OSStatInit();
#endif
#ifdef STATIC_STK
    printf("Total Stack size is 0x%x (bytes)\r\n",task_stack_size);
#endif
    return OS_SUCCESS;
}


OS_APIs unsigned long OS_Random(void)
{
    const INT8U prio = OSTCBCur->OSTCBPrio;
	if(rand_state_list[prio])
    {
        return _rand_r(rand_state_list[prio]);
    }
    else
    {
        rand_state_list[prio] = (struct _rand_state*)OS_MemAlloc(sizeof(struct _rand_state));
        if(rand_state_list[prio])
        {
            _srand_r(rand_state_list[prio], OSTimeGet());
            return _rand_r(rand_state_list[prio]);
        }
        else
        {
            return OSTimeGet();
        }        
    }
}


OS_APIs void OS_Terminate( void )
{
    //vTaskEndScheduler();
}


/* Task: */

OS_APIs s32 OS_TaskCreate( OsTask task, const char *name, u32 stackSize, void *param, u32 pri, OsTaskHandle *taskHandle )
{
    u32* stk_ptr = NULL;
    s32 ret;
    u32 stk_size=(stackSize>>2); //transfer unit to word

#ifdef STATIC_STK
    OS_MutexLock(StkMutex);
printf("OS_TaskCreate:%d, %d\n",(stk_used+stk_size),(task_stack_size>>2));
    if((stk_used+stk_size)>(task_stack_size>>2)){
        printf("Stack is not enough for new task %s\r\n",name);
        //ASSERT(FALSE);
    }
    stk_ptr=&task_stack[stk_used];
    stk_used+=stk_size;
    printf("Free Stack size is 0x%x (bytes)\r\n",(task_stack_size-(stk_used<<2)));
    OS_MutexUnLock(StkMutex);    
#else
    stk_ptr = (void*)OS_MemAlloc(stackSize);
    if(! stk_ptr){
        printf("alloc %s stack fail\n",name);
        return OS_FAILED;
    }
#endif
    printf("OS_TaskCreate =%s,pri=%d,stackSize=%d, stack top=0x%x, stack botton=0x%x\r\n",name,pri,stackSize,&stk_ptr[stk_size-1],&(stk_ptr[0]));

#if OS_TASK_CREATE_EXT_EN > 0
    strcpy(taskUserData[pri].TaskName,name);
    printf("task name:%s,%d\r\n",taskUserData[pri].TaskName,pri);
    taskUserData[pri].TaskCtr=0;
    taskUserData[pri].TaskTotExecTimeFromTiny=0;
    taskUserData[pri].TaskTotExecTimeFromTick=0;
    taskUserData[pri].valid=1;
#endif
#if (OS_STK_GROWTH==0)
    ret = (s32)OSTaskCreate(task, param, stk_ptr, (INT8U)pri);
#else
#ifdef STATIC_STK
#if OS_TASK_CREATE_EXT_EN > 0
        ret = (s32)OSTaskCreateExt(task, param, &(stk_ptr[stk_size - 1]), (INT8U)pri,
                                (INT8U)pri,&(stk_ptr[0]),stk_size,&taskUserData[pri],OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
#else
        ret = (s32)OSTaskCreate(task, param, &(stk_ptr[stk_size - 1]), (INT8U)pri);
#endif
#else
#if OS_TASK_CREATE_EXT_EN > 0
        ret = (s32)OSTaskCreateExt(task, param, &(stk_ptr[stk_size - 1]), (INT8U)pri,
                                    (INT8U)pri,&(stk_ptr[0]),stk_size,&taskUserData[pri],OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
#else
        ret = (s32)OSTaskCreate(task, param, (((u32 *)stk_ptr)+(stackSize/4) - 1), (INT8U)pri);
#endif

#endif
#endif
    if(ret == OS_NO_ERR)
        return OS_SUCCESS;
    else
        printf("OSTaskCreate ret=%d \r\n",ret);

    return OS_FAILED;
}


OS_APIs void OS_TaskDelete(OsTaskHandle taskHandle)
{
    //vTaskDelete(taskHandle);
    OSTaskDel(OS_PRIO_SELF);
}



OS_APIs void OS_StartScheduler( void )
{
    //vTaskStartScheduler();
}

OS_APIs u32 OS_GetSysTick(void)
{
    return OSTimeGet();
}


/* Mutex APIs: */
OS_APIs s32 OS_MutexInit( OsMutex *mutex )
{
    //u8 error;

    //*mutex = xSemaphoreCreateMutex();
    //*mutex = OSMutexCreate(0, &error);
    *mutex = OSSemCreate(1);

    if ( NULL == *mutex ){
        printf("OSSemCreate fail !!!\n");
        return OS_FAILED;
    }
    else{
        return OS_SUCCESS;
    }
}


OS_APIs void OS_MutexLock( OsMutex mutex )
{
    u8 err;
    //xSemaphoreTake( mutex, portMAX_DELAY);
    //OSMutexPend(mutex,0,&err);
    //printf("+\r\n");
    if ( NULL == mutex ){
        //printf("OS_MutexLock mutex = NULL fail !!!\n");
        return;
    }
    OSSemPend(mutex, 0, &err);
    //if(err!=OS_NO_ERR) //ASSERT(FALSE);
}

OS_APIs void OS_TickDelay(u32 ticks)
{
    OSTimeDly((u16)ticks);
}


OS_APIs void OS_MutexUnLock( OsMutex mutex )
{
    if ( NULL == mutex ){
        //printf("OS_MutexUnLock mutex = NULL fail !!!\n");
        return;
    }
    if(OS_NO_ERR!=OSSemPost(mutex)) ;//ASSERT(FALSE);
}

OS_APIs void OS_MutexDelete( OsMutex mutex )
{
    u8 err;

    //OSMutexDel(mutex, OS_DEL_ALWAYS, &err);
    OSSemDel(mutex, OS_DEL_ALWAYS, &err);
}

OS_APIs void OS_MsDelay(u32 ms)
{
	if(ms < TICK_RATE_MS)
		ms = TICK_RATE_MS;
	OSTimeDly(ms/TICK_RATE_MS);
}

#define SEMA_LOCK()		OSSchedLock()
#define SEMA_UNLOCK()		OSSchedUnlock()

#define MSGQ_LOCK()		OSSchedLock()
#define MSGQ_UNLOCK()		OSSchedUnlock()

/* Message Queue: */
OS_APIs s32 OS_MsgQCreate( OsMsgQ *MsgQ, u32 QLen )
{
    u16 size = sizeof(OsMsgQEntry) * QLen;
    void* qpool = OS_MemAlloc(size + sizeof(OsMessgQ));
    OsMsgQ tmpq = 0;

    if(qpool)
    {
        *MsgQ = tmpq = (OsMsgQ)qpool;
        tmpq->qpool = qpool;
		//get double size msg q length
		tmpq->msssageQ = OSQCreate((void*)(((u8*)qpool)+sizeof(OsMessgQ)), (size/sizeof(OsMsgQEntry)));
    }
    else
    {
        printf("%s,size=%d\r\n",__func__,size);
    }

    if(NULL == tmpq)
        return OS_FAILED;
    return OS_SUCCESS;
}

OS_APIs s32 OS_MsgQDelete( OsMsgQ MsgQ)
{
    u8 err=0;
    MSGQ_LOCK();
    
	OSQDel(MsgQ->msssageQ, OS_DEL_ALWAYS, &err);
    OS_MemFree(MsgQ->qpool);
    MSGQ_UNLOCK();
    return ( 0!=err )? OS_FAILED: OS_SUCCESS;
}

OS_APIs s32 OS_MsgQEnqueue(OsMsgQ MsgQ, OsMsgQEntry MsgItem, bool fromISR)
{
    u8 err = 0;
    
postQ:
	
	err = OSQPost(MsgQ->msssageQ, MsgItem);
    if(OS_Q_FULL == err){
        OS_MsDelay(1);
        goto postQ;    
    } 
    
    return ( 0!=err )? OS_FAILED: OS_SUCCESS;
}

OS_APIs s32 OS_MsgQEnqueueTry(OsMsgQ MsgQ, OsMsgQEntry MsgItem, bool fromISR)
{
	u8 err=0;
	
	err = OSQPost(MsgQ->msssageQ, MsgItem);
	return (0 != err) ? OS_FAILED: OS_SUCCESS;
}

OS_APIs s32 OS_MsgQDequeue(OsMsgQ MsgQ, OsMsgQEntry *MsgItem, u32 timeOut, bool fromISR)
{
    u8 err = 0;
	*MsgItem = OSQPend(MsgQ->msssageQ, timeOut, &err);
    return ((err == OS_NO_ERR)? OS_SUCCESS : OS_FAILED);
}


OS_APIs s32 OS_MsgQWaitingSize( OsMsgQ MsgQ )
{
    //return ( uxQueueMessagesWaiting( MsgQ ) );
    return 0;
}


/*==================OS Profiling=========================*/
#if ((OS_CPU_HOOKS_EN>0)&&(OS_TASK_STAT_EN==1))
//#include <os.h>
//#include "drv_l1_timer.h"
//#include "drv_l1_sfr.h"


extern u8 cmd_top_enable;
u32 lastTinyCount=0;
u32 currentTinyCount=0;
u32 lastTickCount=0;
u32 currentTickCount=0;

u32 lastTinyCountStatTask=0;
u32 currentTinyCountStatTask=0;
u32 lastTickCountStatTask=0;
u32 currentTickCountStatTask=0;

u32 acc_cpu_usage=0;
u32 acc_counts=0;

u32 OSCtxSwCtrPerSec;
#define TINY_COUNT(x) ((x*96)/144) // tiny_counter_get is the reference
#define TINY_COUNT_TO_US(x) (((x*266)/100) )
#endif

#if OS_TASK_CREATE_EXT_EN > 0
TASK_USER_DATA taskUserData[64];
#endif

#if 0//((OS_CPU_HOOKS_EN>0)&&(OS_TASK_STAT_EN==1))
void TaskStatHook(void)
{
    u32 cpu_isr=0;
    cpu_isr=OS_EnterCritical();
    currentTinyCountStatTask=R_TIMERD_UPCOUNT&0xFFFF;
    currentTickCountStatTask=OSTime;

    if(cmd_top_enable==1){
        //printf("current time=%d(us)\r\n",TINY_COUNT_TO_US(TINY_COUNT(R_TIMERD_UPCOUNT)));
        DispTaskStatus();
    }else if(cmd_top_enable==2){
        acc_cpu_usage+=OSCPUUsage;
        acc_counts++;
        if ((acc_cpu_usage > 4294967195) || (acc_counts > 4294967294))
        {
            u32 avg_cpu = (acc_cpu_usage/acc_counts);
            printf("Update Average CPU usage = %d%% to avoid overflow\r\n", avg_cpu);
            acc_cpu_usage = 0;
            acc_counts = 0;
        }
    }
    else{
        ClearTaskStatus();
    }

    lastTinyCountStatTask=currentTinyCountStatTask;
    lastTickCountStatTask=currentTickCountStatTask;

    OS_ExitCritical(cpu_isr);
}

void DispTaskStatus(void)
{
    u8 i=0;
    u32 time2=0;
    u32 time1=0;
    OSCtxSwCtrPerSec=OSCtxSwCtr;
    OSCtxSwCtr=0;
    printf("\r\n");
#if (OS_CPU_HOOKS_EN > 0) && (OS_TASK_SW_HOOK_EN > 0) && (OS_TASK_CREATE_EXT_EN>0)
    printf("\33[32m%-30s %-10s %-10s %-10s %-10s\33[0m\r\n","Task Name","Priority","Counter","Tiny Time(us)","Tick Time(ms)");
    printf("\r\n");
    for(i=0;i<sizeof(taskUserData)/sizeof(TASK_USER_DATA);i++){
        if(1==taskUserData[i].valid){
        printf("%-30s %2d      %5d       %5u            %5u                 \r\n",
                taskUserData[i].TaskName,i,taskUserData[i].TaskCtr, TINY_COUNT_TO_US(TINY_COUNT(taskUserData[i].TaskTotExecTimeFromTiny)) ,taskUserData[i].TaskTotExecTimeFromTick*10 );
        taskUserData[i].TaskCtr=0;
        taskUserData[i].TaskTotExecTimeFromTiny=0;
        taskUserData[i].TaskTotExecTimeFromTick=0;
        }
    }
#endif
    printf("\r\n");
    printf("CPU usage = %d%% \r\n",OSCPUUsage);

    time1=((currentTinyCountStatTask|0x10000)-lastTinyCountStatTask)&0xFFFF;
    if(lastTickCountStatTask>currentTickCountStatTask)
        time2 = ((0xFFFFFFFF-lastTickCountStatTask+1)+currentTickCountStatTask);
    else
        time2 = (currentTickCountStatTask-lastTickCountStatTask);

    printf("Calculate interval = %u(us,Tiny) %u(ms,Tick) \r\n",
            TINY_COUNT_TO_US(TINY_COUNT(time1)),time2*10);
}

void ClearTaskStatus(void)
{
    
#if (OS_CPU_HOOKS_EN > 0) && (OS_TASK_SW_HOOK_EN > 0) && (OS_TASK_CREATE_EXT_EN>0)
    u8 i=0;
    u32 avg_cpu = 0;
    if(acc_counts != 0)
    {
        avg_cpu = (acc_cpu_usage/acc_counts);
        printf("Average CPU usage = %d%% \r\n", avg_cpu);
        acc_cpu_usage = 0;
        acc_counts = 0;
    }
    for(i=0;i<sizeof(taskUserData)/sizeof(TASK_USER_DATA);i++){
        if(1==taskUserData[i].valid){
        taskUserData[i].TaskCtr=0;
        taskUserData[i].TaskTotExecTimeFromTiny=0;
        taskUserData[i].TaskTotExecTimeFromTick=0;
        }
    }
#endif
    OSCtxSwCtr=0;    
}
#else
void TaskStatHook(void)
{
}
#endif



