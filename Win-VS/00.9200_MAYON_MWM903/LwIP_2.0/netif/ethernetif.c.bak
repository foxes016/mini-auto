/*
 * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * This file is part of the lwIP TCP/IP stack.
 *
 * Author:
 *
 */
/*
 * This file is a skeleton for developing Ethernet network interface
 * drivers for lwIP. Add code to the low_level functions and do a
 * search-and-replace for the word "ethernetif" to replace it with
 * something that better describes your network interface.
 */

#include "general.h"
#include "../gpi/inc/net.h"
#include "cc.h"
#include "netif/Dm9000.h"
#include "netif/etharp.h"
#include "lwip/opt.h"
#include "lwip/def.h"
#include "lwip/mem.h"
#include "lwip/pbuf.h"
#include "ucos_ii.h"
#include "lwip/Err.h"
#include "task.h"
#include "../gpi/inc/gpi.h"
#include "netif/Ftmac110.h"
#include "UIapi.h"

#if(NIC_SUPPORT == 1)

void WaitlwIPInitDone(void);    
    
#define MTU  1500

/* Define those to better describe your network interface. */
#define IFNAME0 'e'
#define IFNAME1 'n'


u8_t MAC_ADDR[6] = {0x6c,0xf0,0x49,0x11,0x22,0x68};
__align(4)  u8_t  RxBufs[1600];			/* 接收緩衝區 */
__align(4)  u8_t  TxBufs[1600];			/* 發送緩衝區static volatile    */

struct ethernetif
{
    struct eth_addr *ethaddr;
    /* Add whatever per-interface state that is needed here. */
};

OS_EVENT* hEthernetInput;
OS_EVENT* hEthernetOutput;
//* 接收線程堆棧
#define	T_ETHERNETIF_INPUT_STKSIZE		2048  //接收中斷給ethernetif_input任務發送信號，而不直接調用ethernetif_input。
OS_STK  T_ETHERNETIF_INPUT_STK[T_ETHERNETIF_INPUT_STKSIZE];


/* Forward declarations. */
static void ethernetif_input(void *pReserved);



extern u32_t rx_len;







void
low_level_init(struct netif *pstNetif)
{
    printf("entering %s\n", __func__);

    /* set MAC hardware address length */
    pstNetif->hwaddr_len = 6;
    /* set MAC hardware address */
    printf("low_level_init\n");
    pstNetif->hwaddr[0] = MAC_ADDR[0];
    pstNetif->hwaddr[1] = MAC_ADDR[1];
    pstNetif->hwaddr[2] = MAC_ADDR[2];
    pstNetif->hwaddr[3] = MAC_ADDR[3];
    pstNetif->hwaddr[4] = MAC_ADDR[4];
    pstNetif->hwaddr[5] = MAC_ADDR[5];

    /* maximum transfer unit */
    pstNetif->mtu = MTU;
    /* broadcast capability */
    pstNetif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;

    hEthernetInput = OSSemCreate(0);
    hEthernetOutput= OSSemCreate(1);
//  printf("\n ethernetif_input Task start\n");
    OSTaskCreate(ethernetif_input, pstNetif, &T_ETHERNETIF_INPUT_STK[T_ETHERNETIF_INPUT_STKSIZE-1], T_ETHERNETIF_INPUT_PRIO);
}

/*
 * low_level_output():
 *
 * Should do the actual transmission of the packet. The packet is
 * contained in the pbuf that is passed to the function. This pbuf
 * might be chained.
 *
 */

static err_t
low_level_output(struct netif *pstNetif, struct pbuf *pstPbuf) //為簡化設計。每次發送最多佔用一個發送緩衝區。
{
    struct pbuf *__pstSendPbuf ;
    u32_t total_len;
    INT8U os_err;
    
    OSSemPend(hEthernetOutput, OS_IPC_WAIT_FOREVER, &os_err);
    ftmac110_xmit_wait_dma_done();
    total_len = 0;
    for(__pstSendPbuf = pstPbuf; __pstSendPbuf != NULL; __pstSendPbuf = __pstSendPbuf->next)
    {
        if((total_len + __pstSendPbuf->len) > sizeof(TxBufs))
        {
            OSSemPost(hEthernetOutput);
            return ERR_IF;
        }
            
        memcpy(&TxBufs[total_len], __pstSendPbuf->payload, __pstSendPbuf->len);
        total_len +=  __pstSendPbuf->len;
    }
    
    if(total_len < 60)
    {
        const int tmp = total_len;
        total_len = 60;
        memset(&TxBufs[tmp], 0, total_len - tmp);
    }
    
    ftmac110_xmit((u32)TxBufs, total_len);
    OSSemPost(hEthernetOutput);
    return ERR_OK;
}

/*
 * low_level_input():
 *
 * Should allocate a pbuf and transfer the bytes of the incoming
 * packet from the interface into the pbuf.
 *
 */
//extern u16_t GetInputPacketLen(void);
//extern void EMACReadPacket(struct pbuf *__Pstbuf ,u16_t Rlen);
static struct pbuf *low_level_input(struct netif *netif)
{
    int remainLenToRead;
    struct pbuf  *__pstPbuf = 0, *__pstCurPbuf = 0;
    __pstPbuf = NULL;
    u8_t* pRxBufs;

    remainLenToRead = rx_len;
    if((remainLenToRead < 60) || (remainLenToRead > MAX_PKT_SIZE))
    {
        DEBUG_GPIU(" RX Len:%d\n", remainLenToRead);
        return NULL;
    }
        
    __pstPbuf = pbuf_alloc(PBUF_RAW, remainLenToRead, PBUF_POOL);
    if(!__pstPbuf)
    {
        DEBUG_GPIU("NO SPACE\n");
        return NULL;
    }
    
    __pstCurPbuf = __pstPbuf;
    pRxBufs = RxBufs + 2;
    while(remainLenToRead > 0 && __pstCurPbuf != 0)	/*When the size of received packet large than PBUF_POOL_BUFSIZE */
    {
        memcpy(__pstCurPbuf->payload, pRxBufs, __pstCurPbuf->len);
        pRxBufs += __pstCurPbuf->len;
        remainLenToRead -= __pstCurPbuf->len;
        __pstCurPbuf = __pstCurPbuf->next;
    }

    return __pstPbuf;

}


/*
 * ethernetif_input():
 *
 * This function should be called when a packet is ready to be read
 * from the interface. It uses the function low_level_input() that
 * should handle the actual reception of bytes from the network
 * interface.
 *
 */
void
ethernetif_input(void *pReserved)
{
    struct pbuf				*__pstPbuf;
    struct netif			*__pstNetif;
    INT8U					os_err;
    
    WaitlwIPInitDone();
    __pstNetif = (struct netif*)pReserved;
    while(TRUE)
    {
        err_t ret;
        
        OSSemPend(hEthernetInput, OS_IPC_WAIT_FOREVER, &os_err);    //ISR
        if(os_err != OS_NO_ERR)
            continue;
        
        OSSemPend(hEthernetOutput, OS_IPC_WAIT_FOREVER, &os_err);
        rpkt_finish_handler();
        OSSemPost(hEthernetOutput);
        while(rx_len > 0)
        {
            __pstPbuf = low_level_input(__pstNetif); //=eth_rx();
            if(__pstPbuf == NULL)
            {
                printf("pstPbuf = NULL\n");
                break;
            }

            ret = __pstNetif->input(__pstPbuf, __pstNetif);
            if(ret != ERR_OK)
            {
                printf("ethernetif_input: IP input error:%d\n", ret);
                pbuf_free(__pstPbuf);
                __pstPbuf = NULL;
            }
            OSSemPend(hEthernetOutput, OS_IPC_WAIT_FOREVER, &os_err);
            rpkt_finish_handler();
            OSSemPost(hEthernetOutput);
        }
    }
}


void EthernetDropRxFrame(int tick)
{
    INT8U os_err;
    OSSemPend(hEthernetInput, tick, &os_err);    //ISR
    if(os_err == OS_NO_ERR)
    {
        OSSemPend(hEthernetOutput, OS_IPC_WAIT_FOREVER, &os_err);
        rpkt_finish_handler();
        OSSemPost(hEthernetOutput);
        printf("\ndrop rx packet\n");
    }
}



/*
 * ethernetif_init():
 *
 * Should be called at the beginning of the program to set up the
 * network interface. It calls the function low_level_init() to do the
 * actual setup of the hardware.
 *
 */
err_t
ethernetif_init(struct netif *netif)
{
    void *mem_malloc(size_t);
    struct ethernetif *ethernetif;

    LWIP_ASSERT("netif != NULL", (netif != NULL));

    printf("entering %s\n", __func__);
    ethernetif = (struct ethernetif *)mem_malloc(sizeof(struct ethernetif));
    if (ethernetif == NULL)
    {
        printf(("ethernetif_init: out of memory\n"));
        return ERR_MEM;
    }
    /*
     * Initialize the snmp variables and counters inside the struct netif.
     * The last argument should be replaced with your link speed, in units
     * of bits per second.
     */

    netif->state = ethernetif;
    netif->name[0] = IFNAME0;
    netif->name[1] = IFNAME1;
    /* We directly use etharp_output() here to save a function call.
     * You can instead declare your own function an call etharp_output()
     * from it if you have to do some checks before sending (e.g. if link
     * is available...) */
    netif->output = etharp_output;
    netif->linkoutput = low_level_output;

    ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);

    /* initialize the hardware */
    low_level_init(netif);

    return ERR_OK;
}

void Ethernet_Exception(void)  //網口接收中斷服務程序。
{
    u8_t status,masks,rxbyte;

    {
        OSSemPost(hEthernetInput);
        return;
    }
#if 0
    if((status & ISR_PTS)&&(masks & IMR_PTM))
    {
        DM9000_iow(DM9000_ISR,ISR_PTS);
    }
#endif    
}
#endif
