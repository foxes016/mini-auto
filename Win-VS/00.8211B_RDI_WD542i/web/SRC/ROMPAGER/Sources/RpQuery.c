/*
 *	File:		RpQuery.c
 *
 *	Contains:	Query routines - RomPager version
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Copyright:	© 1995-2003 by Allegro Software Development Corporation
 *  All rights reserved.
 *
 *  This module contains confidential, unpublished, proprietary 
 *  source code of Allegro Software Development Corporation.
 *
 *  The copyright notice above does not evidence any actual or intended
 *  publication of such source code.
 *
 *  License is granted for specific uses only under separate 
 *  written license by Allegro Software Development Corporation.
 *  
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *	Change History (most recent first):
 *
 * * * * Release 4.00  * * *
 *		05/24/01	rhb		use AsIndex routines in RpPopQueryIndex,
 *					 		RpGetQueryIndexLevel
 *		02/14/01	rhb		rename rpItemError and eRpItemError_* to 
 *								asItemError and eAsItemError_*
 *		12/19/00	amp		fix compile warning
 *		11/07/00	pjr		eliminate global data pointer (gRpDataPtr)
 *		10/27/00	pjr		move index values to the connection structure
 *		06/02/00	bva		change prototypes for RpCheckQuery, RpStoreQueryValues
 *		02/09/00	bva		use AsEngine.h
 *		01/17/00	bva		theServerDataPtr -> theTaskDataPtr
 *		01/11/00	bva		NULL -> (char *) 0
 * * * * Release 3.06  * * *
 * * * * Release 3.0 * * * *
 *		03/16/99	pjr		rework debug code
 *		12/24/98	pjr		created, moved routines from other sources
 * * * * Release 2.1 * * * *
 * * * * Release 2.0 * * * *
 * * * * Release 1.0 * * * *
 *
 *	To Do:
 */

#include "AsEngine.h"


#if RomPagerServer

#if RomPagerQueryIndex || RomPagerImageMapping

void RpCheckQuery(rpHttpRequestPtr theRequestPtr) {
	char *				thePathPtr;
	Unsigned16 			theTokenLength;
	
	/*
		Queries can be generated for Forms processing on "GET" requests, for
		server-side image map support, and for RomPager indexed requests.
		Forms processing queries take the form "path?name=value,name=value".
		Image map queries take the form "path?h,v". RomPager indexed requests
		take the form "path?,i,j,k,l,m" where i,j,k,l,m are variables set up 
		to control the display/processing of the indexed request.  For form 
		requests that are generated with the "POST" command, the form 
		variables are passed in the HTTP object and not in the HTTP headers.  
		
		If there is a query we check to see if it is a numeric form or a
		"name=value" form.  If it is a "name=value" form, we store the query
		input in the work buffer for the forms processing to handle.  If the
		query values are numeric they were either generated by the browser 
		for an image map, or generated by the RomPager dynamic HTML as a way
		to pass index values. Index values are stored 0-relative, 
		and sent out 1-relative, so we subtract 1 from incoming values.
	*/		
	thePathPtr = RpFindTokenDelimitedPtr(theRequestPtr->fPath, kAscii_Question);
	if (thePathPtr == (char *) 0) {
		/*
			No query, so return.
		*/			
		return;
	}

	/*
		We have a query, so process it.

		Mark the end of the path so the page/form will be found, and
		bump the pointer to the first character of the query.
	*/			

	*(thePathPtr++) = '\0';
	
// +++ _Alphanetworks_Patch_, 11/28/2003, jacob_shih
// to save the url query values
#if 1
	strcpy(theRequestPtr->fSearch, thePathPtr);
#endif
// --- _Alphanetworks_Patch_, 11/28/2003, jacob_shih

	/*
		See if the query is of the "name=value" type or is numeric of the
		form used by image maps.
	*/
	if (*thePathPtr < kAscii_0 || *thePathPtr > kAscii_9) {
		/*
			We have a "name=value" query, so see if there is a
			numeric query appended to it.
		*/
		theTokenLength = RpFindTokenDelimited(thePathPtr, kAscii_Question);
		if (*(thePathPtr + theTokenLength) == '\0') {
			/*
				No numeric query, so store the "name=value" query 
				and return.
			*/			
			RP_STRCPY(theRequestPtr->fHttpWorkBuffer, thePathPtr);
			theRequestPtr->fPostRequestLength = theTokenLength;
			return;
		}
		/*
			Mark the end of the "name=value" query, store it away,
			and set the pointer to the numeric query.
		*/
		*(thePathPtr + theTokenLength) = '\0';
		RP_STRCPY(theRequestPtr->fHttpWorkBuffer, thePathPtr);
		theRequestPtr->fPostRequestLength = theTokenLength;
		thePathPtr += (theTokenLength + 1);
	}

	/*
		Find the numeric query values, convert them into Signed16 values
		and store them in the query index level array. 
	*/
	RpStoreQueryValues(theRequestPtr->fDataPtr, thePathPtr);
	return;
}


void RpStoreQueryValues(rpDataPtr theDataPtr, char *theQueryPtr) {
	Boolean 			theDoneFlag;
	asItemError			theItemError;
	Signed16 			theQueryValue;
	Unsigned16 			theTokenLength;

	theDoneFlag = False;

	while (!theDoneFlag) {
		theTokenLength = RpFindTokenDelimited(theQueryPtr, kAscii_Comma);
		if (*(theQueryPtr + theTokenLength) == '\0') {
			theDoneFlag = True;
		}
		else {
			*(theQueryPtr + theTokenLength) = '\0';
		}

		theItemError = AsStrToSigned16(theQueryPtr, &theQueryValue);

		if (theItemError == eAsItemError_NoError) {
			RpPushQueryIndex(theDataPtr, (Signed16) (theQueryValue - 1));
		}
// +++  
		else
		{
			RpPushQueryIndex(theDataPtr, (Signed16) (theQueryValue - 1));
		}
// ---        
		theQueryPtr += (theTokenLength + 1);
	}

	return;
}


/*
	increments the query index level by one and sets the value of the new 
	query index level (0-relative format) to the passed in value.
*/

void RpPushQueryIndex(void *theTaskDataPtr, Signed16 theQueryValue) {
	rpConnectionPtr		theConnectionPtr;

	theConnectionPtr = ((rpDataPtr) theTaskDataPtr)->fCurrentConnectionPtr;

	if (theConnectionPtr->fIndexDepth < kAsIndexQueryDepth) {
		theConnectionPtr->fIndexDepth += 1;
		theConnectionPtr->fIndexValues[theConnectionPtr->fIndexDepth] =
				theQueryValue;
	}
#if RomPagerDebug
	else {
		RP_PRINTF("RpPushQueryIndex, fIndexDepth overflow, discarding value!\n");
	}
#endif

	return;
}

#endif	/* RomPagerQueryIndex || RomPagerImageMapping */


#if RomPagerQueryIndex

/*
	returns the value of the current query index level (0-relative format),
	and reduces the query index level by one.
*/

Signed16 RpPopQueryIndex(void *theTaskDataPtr) {

	return AsPopVariableIndex(theTaskDataPtr);
}


/*
	returns the value of the query index depth.
*/

Signed8 RpGetQueryIndexLevel(void *theTaskDataPtr) {

	return AsGetVariableIndexLevel(theTaskDataPtr);
}


void * RpGetRepeatWhileValue(void *theTaskDataPtr) {
	rpHttpRequestPtr	theRequestPtr;

	theRequestPtr = ((rpDataPtr) theTaskDataPtr)->fCurrentHttpRequestPtr;
	return theRequestPtr->fNestedItems
					[theRequestPtr->fNestedDepth].fRepeatWhileValue;
}

#endif	/* RomPagerQueryIndex */

#endif	/* RomPagerServer */
